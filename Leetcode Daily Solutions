                                                                           Perfect Number 
Solution:-----------------------------------------------------------------------------------------------------------------------------------------------------------------
class Solution {
public:
    bool checkPerfectNumber(int num) {
        int sum=0;
        for(int i=1;i*i<num;i++)
        {
            if(num%i==0)
            {
                sum+=i;
                if(i*i!=num)
                {
                    sum+=num/i;
                }

            }
        }

        return (sum-num==num);

    }
};
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SQL QUERY :
Group Sold Product By The Date:
Solution:

SELECT sell_date, COUNT(DISTINCT product) AS num_sold, GROUP_CONCAT(DISTINCT product SEPARATOR ',') AS products
FROM Activities
GROUP BY sell_date
ORDER BY sell_date ASC

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Climbing Stairs :
Solution :

class solution {
public:
     int climbStairs(int n)
     {
       int a=0,b=1,c=0;
       for(int i=0 ; i<n; i++)
       {
          c=a+b;
          a=b;
          b=c;
       }
       return c ;
      }
 };
 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------

Minimum Falling Path Sum :
Solution :

class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& matrix) {
       int n=matrix.size();
       for(int i=1;i<n;i++){
           for(int j=0;j<n;j++){
               matrix[i][j]+=min({matrix[i-1][j],matrix[i-1][max(0,j-1)],matrix[i-1][min(n-1,j+1)]});
           }
       } 
       return *min_element(matrix[n-1].begin(),matrix[n-1].end());
    }
};

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
House Robber :
Solution:

class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if(n < 2) return n ? nums[0] : 0;
        vector<int>dp(n);
        dp[0] = nums[0], dp[1] = max(nums[0], nums[1]);
        for(int i = 2; i < n; i++)
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        return dp[n - 1];
    }
};
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Longest Common Subsequenece:
Solution:

class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n=text1.length(),m=text2.length();
        vector<int>curr(m+1,0);
        vector<int>next(m+1,0);
        for(int i=n-1;i>=0;i--){
            for(int j=m-1;j>=0;j--){
                int ans=0;
                if(text1[i]==text2[j]){
                    ans=1+next[j+1];
                }else{
                    ans=max(next[j],curr[j+1]);
                }
                curr[j]=ans;
            }
            next=curr;
        }
        return next[0];
    }
};
------------------------------------------------------------------------------------------------------------------------------------------------------------------------

                                              Reverse Polish Notation
Solution:

#define ll long long
class Solution {
public:
    ll cal ( ll num1 , ll num2 , char &op)
    {
        switch(op)
        {
            case '-':
            return num1-num2;
            break;

            case '+':
            return num1+num2;
            break;

            case '*':
            return num1*num2;
            break;

            case '/':
            return num1/num2;
            break;
        }
        return 0;
    }
    int evalRPN(vector<string>& tokens) {
        
        stack <ll> s ;
        for(auto &i  : tokens)
        {
            if(i=="-" or i=="+" or i=="*" or i=="/")
            {
                ll a = s.top();
                s.pop();
                ll b = s.top();
                s.pop();
                s.push(cal(b,a,i[0]));
            }

            else
            {
                s.push(stoi(i));
            }
        }

        return s.top();
        
    }
};
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
                                                        Implement queue using stack
                                                        
                                                        
 Solution:
 
 class MyQueue {
public:
    stack<int> s1, s2;  // s1 => actual queue like ||  s2 => help s1 to behave as queue
    MyQueue() {}

    void push(int x) {        
        while(!s1.empty()){   // put all values of s1 in s2 for time being
            s2.push(s1.top());
            s1.pop();
        }
        s1.push(x);       // push element to the bottom of s1
        while(!s2.empty()){  // get back all value form s2
            s1.push(s2.top());
            s2.pop();
        }
    }
    
    int pop() {
        int p = s1.top();
        s1.pop();
        return p;
    }
    
    int peek() {
        return s1.top();
    }
    
    bool empty() {
        return s1.empty();
    }
};
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Daily Temprature :-
Solution:-

lass Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        stack<pair<int,int>> st;
        vector<int> ans(n);
        
        for(int i = 0;i<n;i++){
            while(!st.empty() && st.top().first<temperatures[i]){
                auto [num,day] = st.top();
                ans[day] = i-day;
                st.pop();
            }
            st.push({temperatures[i],i});
        }
        return ans;    
    }
};

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Keys and Rooms :-

Solutions:-

class Solution {

    int totalvisit;
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {

        int n = rooms.size();
        boolean [] visited = new boolean[n];

        dfs(rooms, visited , 0);

        return totalvisit==n;
    }


        public void dfs(List<List<Integer>> rooms , boolean [] visited , int start)
        {
             visited[start]=true;
             totalvisit++;

             for(int nei: rooms.get(start))
             {
                 if(!visited[nei])
                 {
                     dfs(rooms, visited,nei);
                 }
             }


        }

        
    }
    --------------------------------------------------------------------------------------------------------------------------------------------------------------------
Possible Bipartition:-
Solution:-

/*representation
like = 1 (blue team)
dislike or don't like = -1 (red team) */

class Solution {
    public boolean possibleBipartition(int n, int[][] dislikes) {
        int[] color=new int[n+1];
        List<Integer>[] graph=new List[n+1];  //array contains list inside it
        for(int i=0;i<=n;i++){
            graph[i]=new ArrayList<>();
        }

        for(int[] v: dislikes){
            graph[v[0]].add(v[1]);
            graph[v[1]].add(v[0]);
        }

        for(int i=1;i<=n;i++){      //iterating on color array
            if(color[i]==0){
               LinkedList<Integer> q=new LinkedList<>();
               q.add(i);
               color[i]=1;

               while(!q.isEmpty()){
                   int top=q.removeFirst();
                   for(int nbr: graph[top]){
                       if(color[nbr]==color[top]) return false;
                       if(color[nbr]==0){
                           color[nbr]=-color[top];  //as we know the neighbaour of popped() element are the ///one tho whome top element don't like/dislikelike therefore -1;  
                           q.add(nbr);
                       }
                   }
               }
            }
        }
        return true;
    }
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
